from typing import List, Dict, Optional
from innovations.innovation import InnovationPool
from core.role import get_role
from core.rules import is_role_unlocked, can_assign_role
from world.player import Player, get_player_by_id
from core.interfaces import RoleInterface
from core.government_types import GovernmentType, get_government_type
from utils.messages import Messages
from core.roles_config import ROLE_CONFIGS
from utils.dice import DiceBag
from utils.logging_config import logger

class Government:
    def __init__(self, simulation: 'core.main.Simulation'):
        self.sim = simulation  # Store the simulation reference
        self.innovation_pool = InnovationPool()
        self.players: List[Player] = []
        self.government_type: GovernmentType = get_government_type("tribal")
        self.assignments: Dict[str, List[Player]] = {key: [] for key in self.government_type.role_mappings}
        self.selection_methods: Dict[str, str] = {key: "" for key in self.government_type.role_mappings}
        self.research_queue: List[str] = []
        self.dice_bag = DiceBag()

    def get_role_points(self) -> Dict[str, int]:
        """Get innovation points generated by each role."""
        return {config.key: config.innovation_points for config in ROLE_CONFIGS.values()}

    def initialize(self):
        """Initialize the government with basic innovations, chieftain, and Tribal government type."""
        for name in ["Fire", "Language", "Toolmaking", "Tribalism", "Hierarchy"]:
            self.innovation_pool.discover(name)
        self.government_type = get_government_type("tribal")
        self.assignments.update({key: [] for key in self.government_type.role_mappings})
        if self.players and not self.get_role_holders("Clan Leader"):
            leader = get_player_by_id(1)  # Player 1 (Alice)
            if leader:
                success, reasons = can_assign_role("Clan Leader", leader, self.assignments,
                                                  self.innovation_pool.discovered, self.government_type)
                if success:
                    if self.assign_role("Clan Leader", leader):
                        Messages.add(f"Initial Clan Leader assigned: {leader.name}")
                else:
                    Messages.add(f"Failed to assign initial Clan Leader: {'; '.join(reasons)}")
            else:
                Messages.add("Failed to assign initial Clan Leader: No player with ID 1 found.")

    def add_player(self, player: Player):
        self.players.append(player)

    def is_player_assigned(self, player_name: str, role_id: str) -> bool:
        """Check if a player is assigned to a specific role."""
        return any(p.name == player_name for p in self.assignments.get(role_id, []))

    def discover_innovation(self, innovation_name: str) -> bool:
        success = self.innovation_pool.discover(innovation_name)
        if success:
            for role_id in list(self.assignments):
                if self.assignments[role_id]:
                    success, reasons = can_assign_role(role_id, self.assignments[role_id][0], self.assignments,
                                                      self.innovation_pool.discovered, self.government_type)
                    if not success:
                        self.assignments[role_id] = []
                        Messages.add(f"Role '{role_id}' reset due to new innovation requirements")
        return success

    def generate_innovation_points(self):
        """Generate innovation points based on assigned base roles."""
        total_new_points = 0
        role_points = self.get_role_points()
        for titled_role, players in self.assignments.items():
            base_roles = self.government_type.role_mappings.get(titled_role, [])
            for base_role in base_roles:
                if is_role_unlocked(base_role, self.innovation_pool.discovered)[0]:
                    new_points = role_points.get(base_role, 0) * len(players)
                    total_new_points += new_points
        Messages.add(f"Generated {total_new_points} innovation points")
        self.innovation_pool.add_points(total_new_points)

    def appoint_player_to_role(self, appointer: Player, role_id: str, appointee: Player) -> bool:
        title_reqs = self.government_type.title_requirements.get(role_id, {})
        if title_reqs.get("selection_method") != "appointment":
            Messages.add(f"{role_id} cannot be appointed.")
            return False
        appointer_role = title_reqs.get("appointer")
        if not appointer_role or appointer not in self.assignments.get(appointer_role, []):
            Messages.add(f"Only {appointer_role} can appoint {role_id}.")
            return False
        success, reasons = can_assign_role(role_id, appointee, self.assignments, self.innovation_pool.discovered,
                                          self.government_type)
        if not success:
            Messages.add(f"Cannot appoint {appointee.name} to {role_id}: {'; '.join(reasons)}")
            return False
        self.assign_role(role_id, appointee)
        Messages.add(f"{appointer.name} appointed {appointee.name} as {role_id}")
        return True

    def assign_role(self, role_id: str, player: Player) -> bool:
        success, reasons = can_assign_role(role_id, player, self.assignments, self.innovation_pool.discovered,
                                           self.government_type)
        logger.debug(f"Attempting to assign {role_id} to {player.name}: Success={success}, Reasons={reasons}")
        if not success:
            Messages.add(f"Failed to assign '{role_id}' to {player.name}: {'; '.join(reasons)}")
            logger.error(f"Assignment failed: {reasons}")
            return False
        if role_id in self.government_type.role_mappings:
            self.assignments.setdefault(role_id, []).append(player)
            assigned_any = False
            for base_role in self.government_type.role_mappings[role_id]:
                unlocked, base_reasons = is_role_unlocked(base_role, self.innovation_pool.discovered)
                if unlocked and get_role(base_role):
                    if base_role not in player.assigned_roles:  # Simplified check
                        player.assign_role(base_role)
                        assigned_any = True
                else:
                    logger.debug(f"Base role {base_role} not unlocked: {base_reasons}")
            if assigned_any:
                Messages.add(f"Assigned '{role_id}' to {player.name}")
                logger.debug(f"Successfully assigned {role_id} to {player.name}")
                return True
            else:
                self.assignments[role_id].remove(player)
                Messages.add(f"Failed to assign '{role_id}' to {player.name}: No valid base roles available")
                logger.error(f"No valid base roles for {player.name} in {role_id}")
                return False
        logger.warning(f"{role_id} not in role_mappings")
        return False

    def remove_role(self, role_id: str, player: Player) -> bool:
        if role_id in self.assignments and player in self.assignments[role_id]:
            self.assignments[role_id].remove(player)
            for base_role in self.government_type.role_mappings.get(role_id, []):
                if base_role in player.assigned_roles:
                    player.assigned_roles.remove(base_role)
            Messages.add(f"Removed {player.name} from '{role_id}'")
            return True
        Messages.add(f"Failed to remove {player.name} from '{role_id}': Not assigned")
        return False

    def get_role_holders(self, role_id: str) -> List[Player]:
        return self.assignments.get(role_id, [])

    def get_player_interfaces(self, player: Player) -> List[RoleInterface]:
        return self.government_type.get_accessible_interfaces(player, self.assignments)

    def set_government_type(self, government_type_name: str) -> bool:
        new_type = get_government_type(government_type_name)
        if new_type and new_type.is_available(self.innovation_pool.discovered):
            self.government_type = new_type
            self.assignments = {key: [] for key in new_type.role_mappings}
            for player in self.players:
                player.assigned_roles = []
            return True
        return False

    def __repr__(self):
        return f"<Government Type: {self.government_type.name}, Players: {len(self.players)}, Innovations: {len(self.innovation_pool.discovered)}, Points: {self.innovation_pool.points}>"