from typing import List, Dict, Optional
from innovation import InnovationPool, INNOVATIONS
from role import Role, get_role, get_unlocked_roles
from selection import SelectionMethod, get_unlocked_selection_methods, get_selection_method
from rules import is_role_unlocked, can_assign_role
from player import Player, get_player_by_id
from interfaces import get_interface, RoleInterface
from government_types import GovernmentType, get_government_type
from messages import Messages
from roles_config import ROLE_CONFIGS

class Government:
    def __init__(self):
        self.innovation_pool = InnovationPool()
        self.players: List[Player] = []
        self.government_type: GovernmentType = get_government_type("tribal")
        self.assignments: Dict[str, List[Player]] = {key: [] for key in self.government_type.role_mappings}
        self.selection_methods: Dict[str, str] = {key: "" for key in self.government_type.role_mappings}
        self.research_queue: List[str] = []

    def get_role_points(self) -> Dict[str, int]:
        """Get innovation points generated by each role."""
        return {config.key: config.innovation_points for config in ROLE_CONFIGS.values()}

    def initialize(self):
        """Initialize the government with basic innovations, chieftain, and Tribal government type."""
        for name in ["Fire", "Language", "Toolmaking", "Tribalism", "Chieftainship"]:
            self.innovation_pool.discover(name)
        self.government_type = get_government_type("tribal")
        if self.government_type.is_valid_selection_method("chieftain", "divine_appointment", self.innovation_pool.discovered):
            self.selection_methods["chieftain"] = "divine_appointment"
        self.assignments.update({key: [] for key in self.government_type.role_mappings})
        if self.players and not self.get_role_holders("chieftain"):
            leader = get_player_by_id(1)  # Player 1 (Alice)
            if leader:
                success, reasons = can_assign_role("chieftain", leader, self.assignments, self.innovation_pool.discovered, self.government_type)
                if success:
                    if self.assign_role("chieftain", leader):
                        Messages.add(f"Initial chieftain assigned: {leader.name}")
                else:
                    Messages.add(f"Failed to assign initial chieftain: {'; '.join(reasons)}")
            else:
                Messages.add("Failed to assign initial chieftain: No player with ID 1 found.")

    def add_player(self, player: Player):
        self.players.append(player)

    def discover_innovation(self, innovation_name: str) -> bool:
        success = self.innovation_pool.discover(innovation_name)
        if success:
            self.assignments.update({key: [] for key in self.government_type.role_mappings})
        return success

    def generate_innovation_points(self):
        """Generate innovation points based on assigned base roles."""
        total_new_points = 0
        role_points = self.get_role_points()
        for titled_role, players in self.assignments.items():
            base_roles = self.government_type.role_mappings.get(titled_role, [])
            for base_role in base_roles:
                if is_role_unlocked(base_role, self.innovation_pool.discovered)[0]:
                    new_points = role_points.get(base_role, 0) * len(players)
                    total_new_points += new_points
        Messages.add(f"Generated {total_new_points} innovation points")
        self.innovation_pool.add_points(total_new_points)

    def discover_random_innovation(self) -> Optional[str]:
        return self.innovation_pool.discover_random()

    def get_available_roles(self) -> List[Role]:
        owned_innovations = self.innovation_pool.discovered
        available_roles = []
        for role in get_unlocked_roles(owned_innovations):
            for titled_role, base_roles in self.government_type.role_mappings.items():
                if role.key in base_roles:
                    available_roles.append(role)
                    break
        return available_roles

    def get_available_selection_methods(self, role_id: str) -> List[SelectionMethod]:
        if role_id not in self.government_type.role_mappings:
            return []
        valid_methods = [
            method for method in get_unlocked_selection_methods(self.innovation_pool.discovered)
            if self.government_type.is_valid_selection_method(role_id, method.key, self.innovation_pool.discovered)
        ]
        return valid_methods

    def set_selection_method(self, role_id: str, method_key: str) -> bool:
        if self.government_type.is_valid_selection_method(role_id, method_key, self.innovation_pool.discovered):
            self.selection_methods[role_id] = method_key
            return True
        return False

    def assign_role(self, role_id: str, player: Player) -> bool:
        success, reasons = can_assign_role(role_id, player, self.assignments, self.innovation_pool.discovered, self.government_type)
        if not success:
            Messages.add(f"Failed to assign '{role_id}' to {player.name}: {'; '.join(reasons)}")
            return False
        if role_id in self.government_type.role_mappings:
            self.assignments.setdefault(role_id, []).append(player)
            assigned_any = False
            for base_role in self.government_type.role_mappings[role_id]:
                unlocked, _ = is_role_unlocked(base_role, self.innovation_pool.discovered)
                if unlocked and get_role(base_role):
                    if base_role not in player.assigned_roles:
                        player.assign_role(base_role)
                        assigned_any = True
            if assigned_any:
                Messages.add(f"Assigned '{role_id}' to {player.name}")
                return True
            else:
                self.assignments[role_id].remove(player)
                Messages.add(f"Failed to assign '{role_id}' to {player.name}: No valid base roles available")
                return False
        return False

    def remove_role(self, role_id: str, player: Player) -> bool:
        if role_id in self.assignments and player in self.assignments[role_id]:
            self.assignments[role_id].remove(player)
            for base_role in self.government_type.role_mappings.get(role_id, []):
                if base_role in player.assigned_roles:
                    player.assigned_roles.remove(base_role)
            Messages.add(f"Removed {player.name} from '{role_id}'")
            return True
        Messages.add(f"Failed to remove {player.name} from '{role_id}': Not assigned")
        return False

    def get_role_holders(self, role_id: str) -> List[Player]:
        return self.assignments.get(role_id, [])

    def add_to_research_queue(self, innovation_name: str) -> bool:
        discoverable = [i.name for i in self.innovation_pool.get_discoverable()]
        if innovation_name in discoverable and innovation_name not in self.research_queue:
            self.research_queue.append(innovation_name)
            return True
        return False

    def remove_from_research_queue(self, innovation_name: str) -> bool:
        if innovation_name in self.research_queue:
            self.research_queue.remove(innovation_name)
            return True
        return False

    def process_research_queue(self):
        queue_copy = list(self.research_queue)
        for innovation_name in queue_copy:
            innovation = INNOVATIONS.get(innovation_name)
            if not innovation:
                Messages.add(f"Invalid innovation {innovation_name} in queue; skipping.")
                self.research_queue.remove(innovation_name)
                continue
            if innovation_name in self.innovation_pool.discovered:
                Messages.add(f"{innovation_name} is already discovered; skipping.")
                self.research_queue.remove(innovation_name)
                continue
            if self.innovation_pool.points >= innovation.cost:
                self.innovation_pool.spend_points(innovation.cost)
                self.innovation_pool.discovered.add(innovation_name)
                Messages.add(f"Discovered {innovation_name} from research queue (Cost: {innovation.cost}).")
                self.research_queue.remove(innovation_name)
            else:
                Messages.add(
                    f"Insufficient points ({self.innovation_pool.points}) to discover {innovation_name} (Cost: {innovation.cost})."
                )

    def get_player_interfaces(self, player: Player) -> List[RoleInterface]:
        return self.government_type.get_accessible_interfaces(player, self.assignments)

    def set_government_type(self, government_type_name: str) -> bool:
        new_type = get_government_type(government_type_name)
        if new_type and new_type.is_available(self.innovation_pool.discovered):
            self.government_type = new_type
            old_assignments = self.assignments
            self.assignments = {key: [] for key in new_type.role_mappings}
            self.selection_methods = {key: "" for key in new_type.role_mappings}
            for player in self.players:
                player.assigned_roles = []
            for role_id, method_key in list(self.selection_methods.items()):
                if not self.government_type.is_valid_selection_method(role_id, method_key, self.innovation_pool.discovered):
                    self.selection_methods[role_id] = ""
            return True
        return False

    def __repr__(self):
        return f"<Government Type: {self.government_type.name}, Players: {len(self.players)}, Innovations: {len(self.innovation_pool.discovered)}, Points: {self.innovation_pool.points}>"